<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>黑白棋教學網</title>
  <style>
    :root { --cell: 54px; --gap: 14px; --boardPad: 10px; --boardGap: 2px; --boardBd: 1px; --coord: 26px; }
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 0; padding: 18px; background:#0f172a; color:#e2e8f0; }
    .app { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1.05fr 0.95fr; gap: var(--gap); }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr; } :root{ --cell: 46px; } }

    .panel { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 14px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .rowLeft { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    select, button {
      border-radius: 12px;
      padding: 9px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#e2e8f0;
    }
    select option { background-color: #0f172a; color: #e2e8f0; }
    select option:hover, select option:checked { background-color: #1c4e80; color: #ffffff; }

    button { cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.12); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor:not-allowed; }
    .pill { padding: 4px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); font-size: 17px; line-height: 1.2; }
    .muted { opacity: 0.85; font-size: 14px; line-height:1.45; }

    .boardFrame{
      position: relative;
      padding-left: var(--coord);
      padding-top:  var(--coord);
      display: inline-block;
    }
    .coordTop{
      position: absolute;
      left: calc(var(--coord) + var(--boardPad) + var(--boardBd));
      top: 0;
      display: grid;
      grid-template-columns: repeat(8, var(--cell));
      gap: var(--boardGap);
      height: var(--coord);
      width: calc(8 * var(--cell) + 7 * var(--boardGap));
      align-items: center;
      justify-items: center;
      font-size: 18px;
      opacity: 0.9;
    }
    .coordLeft{
      position: absolute;
      left: 0;
      top: calc(var(--coord) + var(--boardPad) + var(--boardBd));
      display: grid;
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--boardGap);
      width: var(--coord);
      height: calc(8 * var(--cell) + 7 * var(--boardGap));
      align-items: center;
      justify-items: center;
      font-size: 18px;
      opacity: 0.9;
    }

    .boardWrap { display:flex; justify-content:center; }
    .board{
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--boardGap);
      background: rgba(255,255,255,0.08);
      padding: var(--boardPad);
      border-radius: 16px;
      border: var(--boardBd) solid rgba(255,255,255,0.12);
      user-select:none;
      touch-action: manipulation;
    }
    .cell {
      width: var(--cell); height: var(--cell);
      border-radius: 10px;
      position: relative;
      outline: 1px solid rgba(0,0,0,0.15);
      display:flex; align-items:center; justify-content:center;
    }
    .boardControls{
      margin-top: 12px;
      display:flex;
      justify-content:center;
    }
    .boardControls .rowLeft{
      justify-content:center;
    }
    body.gamesMode .cell { background:#166534; }
    body.learningMode .cell { background:#166551; }
    body.varMode .cell { background:#1c4e80; }
    body.varMode .board { border-color: rgba(147,197,253,0.35); }
    body.varMode .item.active { background: rgba(147,197,253,0.14); outline-color: rgba(147,197,253,0.25); }

    #variationBox { display:flex; flex-direction:column; gap:8px; }
    .varBtn {
      display:flex; justify-content:space-between; align-items:center;
      border-radius: 12px; padding: 9px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#e2e8f0;
      cursor:pointer;
    }
    .varBtn:hover { background: rgba(255,255,255,0.12); }
    .varBtn small { opacity: .85; }

    .disc {
      width: calc(var(--cell) * 0.82);
      height: calc(var(--cell) * 0.82);
      border-radius: 50%;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.10),
        0 3px 6px rgba(0,0,0,0.25);
    }
    .black { background: radial-gradient(circle at 35% 30%, #64748b 0%, #111827 60%, #0b1220 100%); }
    .white { background: radial-gradient(circle at 35% 30%, #ffffff 0%, #e2e8f0 55%, #cbd5e1 100%); }

    .lastMove::after{
      content:"";
      position:absolute;
      width: calc(var(--cell) * 0.28);
      height: calc(var(--cell) * 0.28);
      border-radius: 8px;
      border: 2px solid rgba(250,204,21,0.95);
      box-shadow: 0 0 0 3px rgba(250,204,21,0.18);
    }

    .right {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height: 0;
    }
    .moves {
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 0;
    }

    .moveSection { order: 1; }
    .detailWrap  { order: 2; }
    .moveSection > .row { margin-bottom: 8px;}
    .list {
      overflow:auto;
      max-height: 240px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.12);
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }
    .item {
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      cursor:pointer;
      display:flex;
      gap: 10px;
      align-items:flex-start;
      justify-content:space-between;
      margin-bottom: 4px;
    }
    .item:last-child { border-bottom: 0; }
    .item:hover { background: rgba(255,255,255,0.06); }
    .item.active { background: rgba(250,204,21,0.10); outline: 1px solid rgba(250,204,21,0.20); }
    .tag { font-size: 14px; opacity: 0.85; white-space:nowrap; }
    .tag.moveNo { min-width: 90px; text-align: right; }
    .tag.moveNo::before { content: "★ "; visibility: hidden; }
    .item.hasVar .tag.moveNo::before { visibility: visible; }
    .mainText { font-size: 17px; line-height: 1.4; }
    .lessonTitle { font-size: 18px; }
    .detailBox {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.12);
      padding: 12px;
      min-height: 120px;
      white-space: pre-wrap;
      line-height: 1.5;
      font-size: 18px;
    }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); }

    .error {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(248,113,113,0.35);
      background: rgba(248,113,113,0.10);
      color: #fecaca;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }

    @media (max-width: 980px){
      .detailWrap  { order: 1; }
      .moveSection { order: 2; }
      .list { max-height: 200px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="panel">
      <h1>黑白棋教學網v2.12</h1>
      <div class="row">
        <div class="rowLeft">
          <select id="modeSelect" aria-label="Select mode">
            <option value="learning">教學</option>
            <option value="games">解說</option>
          </select>

          <select id="gameSelect" aria-label="Select item"></select>

          <span class="pill">黑：<b id="bCount">2</b>　白：<b id="wCount">2</b></span>
        </div>
      </div>

      <div id="errorBox" class="error" style="display:none;"></div>

      <div style="height:12px;"></div>
      <div class="boardWrap">
        <div class="boardFrame">
          <div class="coordTop" aria-hidden="true"></div>
          <div class="coordLeft" aria-hidden="true"></div>
          <div class="board" id="board" aria-label="Othello board"></div>
        </div>
      </div>

      <div class="boardControls">
        <div class="rowLeft">
          <button id="firstBtn">⏮ 第一手</button>
          <button id="backBtn" style="display:none;">↩ 原對局</button>
          <button id="prevBtn">◀ 上一手</button>
          <button id="nextBtn">下一手 ▶</button>
          <button id="lastBtn">最後一手 ⏭</button>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel moves">
        <div class="detailWrap">
          <div class="detailBox" id="detailBox">（尚未載入）</div>
          <div id="variationBox" style="margin-top:10px;"></div>
        </div>

        <div class="moveSection">
          <div class="row">
            <div class="rowLeft">
              <span class="pill" id="listTitle">步驟清單 </span>
            </div>
            <div class="hotkeys muted" id="hotkeysText">
              快捷鍵：<span class="kbd">←</span>/<span class="kbd">→</span> 前後手、<span class="kbd">Home</span>/<span class="kbd">End</span> 首尾。
            </div>
          </div>
          <div class="list" id="moveList" aria-label="List"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Core constants =====
  const N = 8;
  const EMPTY = 0, BLACK = 1, WHITE = 2;
  const dirs = [
    [-1,-1],[-1,0],[-1,1],
    [0,-1],        [0,1],
    [1,-1],[1,0],[1,1]
  ];
  function other(p){ return p===BLACK ? WHITE : BLACK; }
  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  // ===== Default init board =====
  function initBoard(){
    const b = Array.from({length:N}, () => Array(N).fill(EMPTY));
    b[3][3] = WHITE; b[3][4] = BLACK;
    b[4][3] = BLACK; b[4][4] = WHITE;
    return b;
  }

  // ===== Record token parsing (still keeps original record format) =====
  function parseMove(s){
    if (!s) return null;
    const t = String(s).trim().toLowerCase();
    if (t === "pass") return { pass:true };
    const file = t.charCodeAt(0) - "a".charCodeAt(0);
    const rank = parseInt(t.slice(1), 10) - 1;
    if (Number.isNaN(rank) || file < 0 || file >= 8 || rank < 0 || rank >= 8) return null;
    return { r: rank, c: file, pass:false };
  }

  function getFlips(board, r, c, p){
    if (board[r][c] !== EMPTY) return [];
    const opp = other(p);
    const flips = [];
    for (const [dr,dc] of dirs){
      let rr = r + dr, cc = c + dc;
      const line = [];
      while (inBounds(rr,cc) && board[rr][cc] === opp){
        line.push([rr,cc]);
        rr += dr; cc += dc;
      }
      if (line.length && inBounds(rr,cc) && board[rr][cc] === p) flips.push(...line);
    }
    return flips;
  }

  function hasAnyLegalMove(board, p){
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== EMPTY) continue;
        if (getFlips(board, r, c, p).length) return true;
      }
    }
    return false;
  }

  function applyMove(board, moveObj, p){
    if (moveObj.pass) return { ok:true, last:null, board };
    const {r,c} = moveObj;
    const flips = getFlips(board, r, c, p);
    if (!flips.length) return { ok:false, last:null, board };
    board[r][c] = p;
    for (const [rr,cc] of flips) board[rr][cc] = p;
    return { ok:true, last:{r,c}, board };
  }

  function countDiscs(board){
    let b=0,w=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c]===BLACK) b++;
        else if (board[r][c]===WHITE) w++;
      }
    }
    return {b,w};
  }

  // ===== UI elements =====
  const boardEl = document.getElementById("board");
  const modeSelect = document.getElementById("modeSelect");
  const gameSelect = document.getElementById("gameSelect");
  const moveListEl = document.getElementById("moveList");
  const listTitleEl = document.getElementById("listTitle");
  const hotkeysEl = document.getElementById("hotkeysText");
  const detailBox = document.getElementById("detailBox");
  const errorBox = document.getElementById("errorBox");

  const bCountEl = document.getElementById("bCount");
  const wCountEl = document.getElementById("wCount");

  const firstBtn = document.getElementById("firstBtn");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const lastBtn = document.getElementById("lastBtn");
  const backBtn = document.getElementById("backBtn");

  const variationBox = document.getElementById("variationBox");
  const coordTopEl  = document.querySelector(".coordTop");
  const coordLeftEl = document.querySelector(".coordLeft");

  function renderCoords(){
    if (coordTopEl){
      coordTopEl.innerHTML = "";
      "ABCDEFGH".split("").forEach(ch => {
        const d = document.createElement("div");
        d.textContent = ch;
        coordTopEl.appendChild(d);
      });
    }
    if (coordLeftEl){
      coordLeftEl.innerHTML = "";
      for (let i=1;i<=8;i++){
        const d = document.createElement("div");
        d.textContent = String(i);
        coordLeftEl.appendChild(d);
      }
    }
  }

  // ===== App state =====
  let appMode = "learning";

  // shared playback state
  let step = 0;

  // games mode state
  let gameIndex = [];
  let currentGame = null;
  let currentIndex = 0;
  let mode = "main";   // "main" | "var"
  let varCtx = null;

  // learning mode state
  let lessonIndex = [];
  let currentLesson = null;   // { id,title,positions:[{title,meta,playableGame}] }
  let lessonPos = 0;          // current position index

  function showError(msg){
    errorBox.style.display = "block";
    errorBox.textContent = msg;
  }
  function clearError(){
    errorBox.style.display = "none";
    errorBox.textContent = "";
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`${url} 讀取失敗（HTTP ${res.status}）`);
    return await res.json();
  }

  function normalizeIndexEntry(e){
    const id = String(e?.id ?? "");
    const title = String(e?.title ?? id ?? "Untitled");
    const file = String(e?.file ?? "");
    if (!id || !file) return null;
    return { id, title, file };
  }

  function buildMovesFromRecord(record, comments){
    const rec = String(record ?? "").trim().toLowerCase();
    if (!rec) return [];
    if (rec.length % 2 !== 0) throw new Error("record 長度錯誤：必須是 2 的倍數（每手 2 字元）");
    const c = (comments && typeof comments === "object") ? comments : {};
    const moves = [];
    for (let i=0;i<rec.length;i+=2){
      const s = (i/2)+1;
      const mv = rec.slice(i,i+2);
      moves.push({ move: mv, comment: String(c[String(s)] ?? c[s] ?? "") });
    }
    return moves;
  }

  // ===== Future-friendly start board / start turn parsing =====
  function parseStartBoard(raw){
    // games old json: default init
    return initBoard();
  }
  function parseStartTurn(raw){
    return BLACK;
  }

  function parseStartBoardFromPosition(posRaw){
  const v = posRaw?.startBoard ?? posRaw?.initBoard ?? posRaw?.board ?? null;
  if (!v) return initBoard();
  if (typeof v !== "string") return initBoard();

  const rows = v.split("/").map(s => s.trim()).filter(Boolean);
  if (rows.length !== 8) return initBoard();

  const b = Array.from({length:8}, () => Array(8).fill(EMPTY));
  for (let r=0;r<8;r++){
    const line = rows[r];
    if (line.length < 8) return initBoard();
    for (let c=0;c<8;c++){
      const ch = line[c];
      if (ch === "B" || ch === "b") b[r][c] = BLACK;
      else if (ch === "W" || ch === "w") b[r][c] = WHITE;
      else b[r][c] = EMPTY; // '.' 或其他字元都當空
    }
  }
  return b;
}

  function parseStartTurnFromPosition(posRaw){
    const t = posRaw?.startTurn ?? posRaw?.turn ?? posRaw?.startPlayer ?? null;
    if (t === WHITE || t === "W" || t === "w" || t === "white") return WHITE;
    if (t === BLACK || t === "B" || t === "b" || t === "black") return BLACK;
    return BLACK;
  }

  // ===== Games data model =====
  function normalizeGame(g){
    const id = String(g?.id ?? "");
    const title = String(g?.title ?? id ?? "");
    const meta = String(g?.meta ?? "");
    if (!("record" in g)) {
      throw new Error("對局檔格式錯誤：缺少 record 欄位");
    }
    const record = String(g.record ?? "").trim().toLowerCase();
    const comments =
      (g?.comments && typeof g.comments === "object") ? g.comments : {};
    const moves = record
      ? buildMovesFromRecord(record, comments)
      : [];

    const variations = (g?.variations && typeof g.variations === "object") ? g.variations : {};

    const startBoard = parseStartBoard(g);
    const startTurn = parseStartTurn(g);

    return { type:"game", id, title, meta, moves, variations, startBoard, startTurn };
  }

  // ===== Learning data model =====
  function normalizeLesson(raw){
    const type = String(raw?.type ?? "lesson");
    if (type !== "lesson") throw new Error("教學檔格式錯誤：type 必須是 lesson");

    const id = String(raw?.id ?? "");
    const title = String(raw?.title ?? id ?? "Lesson");
    const positionsRaw = Array.isArray(raw?.positions) ? raw.positions : [];
    if (!positionsRaw.length) throw new Error("教學檔格式錯誤：positions 必須是非空陣列");

    const positions = positionsRaw.map((p, idx) => {
      const pTitle = String(p?.title ?? `局面 ${idx+1}`);
      const pMeta  = String(p?.meta ?? "");
      if (!("record" in p)) {
        throw new Error(`教學檔格式錯誤：positions[${idx}] 缺少 record 欄位`);
      }
      const record = String(p.record ?? "").trim().toLowerCase();
      const comments =
        (p?.comments && typeof p.comments === "object") ? p.comments : {};
      const moves = record
        ? buildMovesFromRecord(record, comments)
        : [];

      const startBoard = parseStartBoardFromPosition(p);
      const startTurn = parseStartTurnFromPosition(p);

      const playable = {
        type: "position",
        id: `pos_${idx+1}`,
        title: pTitle,
        meta: pMeta,
        moves,
        variations: {},      // 教學不設置變化圖
        startBoard,
        startTurn,
        // 讓 renderDetail 能在 step=0 顯示額外說明（例如 comments["0"]）
        comments0: String(comments["0"] ?? comments[0] ?? "")
      };

      return { title: pTitle, meta: pMeta, playable };
    });
    return { type:"lesson", id, title, positions };
  }

  // ===== Replay core (PASS via legal-move guard; shared by game/position) =====
  function computePositionFrom(startBoard, startTurn, game, step){
    let board = startBoard.map(row => row.slice());
    let turn = startTurn;
    let last = null;

    for (let i=0;i<step;i++){
      const m = game.moves[i];
      const mo = parseMove(m.move);
      if (!mo) continue;

      // auto PASS: if current turn has no legal move, skip to other; up to 2 times
      let guard = 0;
      while (!hasAnyLegalMove(board, turn)) {
        turn = other(turn);
        guard++;
        if (guard >= 2) break;
      }
      if (guard >= 2 && !hasAnyLegalMove(board, turn)) break;

      // explicit PASS token: do nothing but keep "turn" (because our record may not contain pass)
      if (mo.pass){
        continue;
      }

      const res = applyMove(board, mo, turn);

      // if token seems belong to other side (legacy data), try alternate
      if (!res.ok) {
        const alt = other(turn);
        const res2 = applyMove(board, mo, alt);
        if (res2.ok) {
          last = res2.last;
          turn = other(alt);
          continue;
        }
        continue;
      }

      last = res.last;
      turn = other(turn);
    }
    return { board, turn, last };
  }

  function computePosition(game, step){
    const startBoard = game?.startBoard ? game.startBoard : initBoard();
    const startTurn  = (game && (game.startTurn===BLACK || game.startTurn===WHITE)) ? game.startTurn : BLACK;
    return computePositionFrom(startBoard, startTurn, game, step);
  }

  function buildPlayersForMoves(startBoard, startTurn, game){
    const players = [];
    let board = startBoard.map(row => row.slice());
    let turn = startTurn;

    for (let i=0;i<game.moves.length;i++){
      const mo = parseMove(game.moves[i].move);
      if (!mo){
        players[i] = turn;
        continue;
      }

      let guard = 0;
      while (!hasAnyLegalMove(board, turn)) {
        turn = other(turn);
        guard++;
        if (guard >= 2) break;
      }
      if (guard >= 2 && !hasAnyLegalMove(board, turn)) {
        players[i] = turn;
        continue;
      }

      players[i] = turn;

      if (mo.pass) continue;

      const res = applyMove(board, mo, turn);
      if (!res.ok) {
        const alt = other(turn);
        const res2 = applyMove(board, mo, alt);
        if (res2.ok) {
          turn = other(alt);
          continue;
        }
        continue;
      }
      turn = other(turn);
    }
    return players;
  }

  // ===== Renderers =====
  function renderBoard(board, last){
    boardEl.innerHTML = "";
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        if (last && last.r===r && last.c===c) cell.classList.add("lastMove");

        const v = board[r][c];
        if (v !== EMPTY){
          const d = document.createElement("div");
          d.className = "disc " + (v===BLACK ? "black" : "white");
          cell.appendChild(d);
        }
        boardEl.appendChild(cell);
      }
    }
  }

  function scrollActiveInList(){
    if (!moveListEl) return;
    const active = moveListEl.querySelector(".item.active");
    if (!active) return;

    const top = active.offsetTop;
    const bottom = top + active.offsetHeight;

    const viewTop = moveListEl.scrollTop;
    const viewBottom = viewTop + moveListEl.clientHeight;

    if (top < viewTop) moveListEl.scrollTop = top - 8;
    else if (bottom > viewBottom) moveListEl.scrollTop = bottom - moveListEl.clientHeight + 8;
  }

  function renderMoveList(game, startBoardForThisGame, startTurnForThisGame){
    moveListEl.innerHTML = "";
    const activeStep = (mode === "var" && varCtx) ? varCtx.varStep : step;

    const players = buildPlayersForMoves(startBoardForThisGame, startTurnForThisGame, game);

    const initItem = document.createElement("div");
    initItem.className = "item" + (activeStep===0 ? " active":"");
    initItem.innerHTML = `
      <div>
        <div class="mainText"><b>初始局面</b></div>
        <div class="tag">Move 0</div>
      </div>
      <div class="tag">—</div>
    `;
    initItem.addEventListener("click", () => {
      if (mode === "var" && varCtx) varCtx.varStep = 0;
      else step = 0;
      renderAll();
    });
    moveListEl.appendChild(initItem);

    for (let i=0;i<game.moves.length;i++){
      const m = game.moves[i];
      const s = i+1;
      const key = String(s);
      const hasVar = Array.isArray(game.variations?.[key]?.entries) && game.variations[key].entries.length;

      const item = document.createElement("div");
      item.className = "item" + (activeStep===s ? " active":"") + (hasVar ? " hasVar" : "");

      const p = players[i];
      const playerLabel = (p === BLACK) ? "黑" : "白";

      const moveLower = String(m.move).toLowerCase();
      const moveText = (moveLower === "pass") ? "PASS" : String(m.move);

      const shortComment = (m.comment || "").trim().replace(/\s+/g," ");
      const preview = shortComment.length ? shortComment.slice(0, 24) + (shortComment.length>24 ? "…" : "") : "";

      item.innerHTML = `
        <div>
          <div class="mainText"><b>${playerLabel}</b>：${moveText}</div>
          <div class="tag">${preview}</div>
        </div>
        <div class="tag moveNo">Move ${s}</div>
      `;
      item.addEventListener("click", () => {
        if (mode === "var" && varCtx) varCtx.varStep = s;
        else step = s;
        renderAll();
      });
      moveListEl.appendChild(item);
    }

    scrollActiveInList();
  }

  function renderPositionList(lesson){
    moveListEl.innerHTML = "";
    const active = lessonPos;

    for (let i=0;i<lesson.positions.length;i++){
      const p = lesson.positions[i];
      const item = document.createElement("div");
      item.className = "item" + (i===active ? " active":"");
      item.innerHTML = `
        <div>
          <div class="lessonTitle">${escapeHtml(p.title)}</div>
        </div>
        <div class="tag moveNo">#${i+1}</div>
      `;
      item.addEventListener("click", () => {
        lessonPos = i;
        step = 0;
        renderAll();
      });
      moveListEl.appendChild(item);
    }

    scrollActiveInList();
  }

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function renderDetail(game, pos){
    if (variationBox) variationBox.innerHTML = "";

    if (appMode === "learning"){
      if (step === 0){
        const base = (game.meta || "").trim();
        detailBox.textContent = base
          ? `【${game.title || "教學局面"}】\n${base}`
          : "（局面開始）";
      } else {
        const i = step - 1;
        const m = game.moves[i];
        detailBox.textContent = String((m?.comment || "")).trim();
      }
      return;
    }

    // ===== games mode (same as your current behavior) =====
    if (mode === "var" && varCtx){
      if (varCtx.varStep === 0){
        detailBox.textContent = `【變化分支】${varCtx.varTitle}`;
      } else {
        const i = varCtx.varStep - 1;
        const m = varCtx.varGame.moves[i];
        detailBox.textContent = String((m.comment || "")).trim();
      }
      return;
    }

    if (step === 0){
      detailBox.textContent = game.meta ? `【對局資訊】\n${game.meta}` : "（初始局面）";
    } else {
      const i = step - 1;
      const m = game.moves[i];
      const comment = String((m.comment || "")).trim();
      const key = String(step);
      const entries = game.variations?.[key]?.entries;
      const hasVarHere = Array.isArray(entries) && entries.length;
      detailBox.textContent = hasVarHere ? `【變化圖】\n${comment}`: comment;
    }

    const key = String(step);
    const vPack = game.variations?.[key];
    const entries = vPack?.entries;
    if (variationBox && Array.isArray(entries) && entries.length){
      entries.forEach((entry) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "varBtn";
        const name = entry.name || "變化";
        const rec = String(entry.record || "");
        btn.innerHTML = `<span><b>${escapeHtml(name)}</b></span><small>${escapeHtml(rec)}</small>`;
        btn.addEventListener("click", () => enterVariation(step, entry, vPack));
        variationBox.appendChild(btn);
      });
    }
  }

  function renderHeaderCounts(pos){
    const {b,w} = countDiscs(pos.board);
    if (bCountEl) bCountEl.textContent = b;
    if (wCountEl) wCountEl.textContent = w;
  }

  function renderControlsState(game){
    if (appMode === "learning"){
      // labels
      firstBtn.textContent = "◀ 上一題";
      lastBtn.textContent  = "下一題 ▶";

      const atStartStep = (step === 0);
      const atEndStep = (step === game.moves.length);
      const atFirstPos = (lessonPos <= 0);
      const atLastPos = (currentLesson ? lessonPos >= currentLesson.positions.length - 1 : true);

      firstBtn.disabled = atFirstPos;
      lastBtn.disabled = atLastPos;

      prevBtn.disabled = atStartStep;
      nextBtn.disabled = atEndStep;

      // learning has no variations / back button
      backBtn.style.display = "none";
      firstBtn.style.display = "";
      document.body.classList.remove("varMode");
      return;
    }

    // games mode labels
    firstBtn.textContent = "⏮ 第一手";
    lastBtn.textContent  = "最後一手 ⏭";

    const atStart = (mode === "var" && varCtx) ? (varCtx.varStep === 0) : (step === 0);
    const atEnd = (mode === "var" && varCtx) ? (varCtx.varStep === varCtx.varGame.moves.length) : (step === game.moves.length);
    const inVar = (mode === "var" && varCtx);

    firstBtn.disabled = atStart;
    prevBtn.disabled  = inVar ? false : atStart;
    nextBtn.disabled  = atEnd;
    lastBtn.disabled  = atEnd;

    if (mode === "var") {
      backBtn.style.display  = "";
      firstBtn.style.display = "none";
      document.body.classList.add("varMode");
    } else {
      backBtn.style.display  = "none";
      firstBtn.style.display = "";
      document.body.classList.remove("varMode");
    }
  }

  function renderListHeader(){
    if (appMode === "learning"){
      listTitleEl.textContent = "局面清單";
      hotkeysEl.innerHTML = `快捷鍵：<span class="kbd">←</span>/<span class="kbd">→</span> 前後手、<span class="kbd">Home</span>/<span class="kbd">End</span> 首尾。`;
      return;
    }
    listTitleEl.textContent = "步驟清單";
    hotkeysEl.innerHTML = `快捷鍵：<span class="kbd">←</span>/<span class="kbd">→</span> 前後手、<span class="kbd">Home</span>/<span class="kbd">End</span> 首尾。`;
  }

  // ===== Main renderAll() routing by appMode =====
  function renderAll(){
    renderListHeader();

    if (appMode === "learning"){
      if (!currentLesson){
        detailBox.textContent = "（尚未載入教學）";
        if (variationBox) variationBox.innerHTML = "";
        moveListEl.innerHTML = "";
        return;
      }

      const posObj = currentLesson.positions[lessonPos]?.playable;
      if (!posObj){
        detailBox.textContent = "（找不到教學局面）";
        if (variationBox) variationBox.innerHTML = "";
        moveListEl.innerHTML = "";
        return;
      }

      const pos = computePosition(posObj, step);
      renderBoard(pos.board, pos.last);
      renderPositionList(currentLesson);
      renderDetail(posObj, pos);
      renderHeaderCounts(pos);
      renderControlsState(posObj);
      return;
    }

    // ===== games mode =====
    if (!currentGame){
      detailBox.textContent = "（尚未載入對局）";
      if (variationBox) variationBox.innerHTML = "";
      moveListEl.innerHTML = "";
      return;
    }

    if (mode === "var" && varCtx){
      const pos = computePositionFrom(varCtx.baseBoard, varCtx.baseTurn, varCtx.varGame, varCtx.varStep);
      renderBoard(pos.board, pos.last);
      renderMoveList(varCtx.varGame, varCtx.baseBoard, varCtx.baseTurn);
      renderDetail(varCtx.varGame, pos);
      renderHeaderCounts(pos);
      renderControlsState(varCtx.varGame);
      return;
    }

    const pos = computePosition(currentGame, step);
    renderBoard(pos.board, pos.last);
    renderMoveList(currentGame, currentGame.startBoard ?? initBoard(), currentGame.startTurn ?? BLACK);
    renderDetail(currentGame, pos);
    renderHeaderCounts(pos);
    renderControlsState(currentGame);
  }

  // ===== Variations (games only) =====
  function enterVariation(parentStep, entry, vPack){
    if (!currentGame) throw new Error("currentGame 尚未載入");

    const baseStep = (vPack && Number.isInteger(vPack.baseStep))
      ? vPack.baseStep
      : parentStep;

    const basePos = computePosition(currentGame, baseStep);

    const varGame = {
      type: "var",
      id: "var",
      title: entry?.name || "變化",
      meta: "",
      moves: buildMovesFromRecord(entry?.record, entry?.comments),
      variations: {},
      startBoard: basePos.board,
      startTurn: basePos.turn
    };

    if (!varGame.moves.length) throw new Error("這個變化圖的 record 是空的，無法進入");

    appMode = "learning";
    document.body.classList.add("learningMode");
    mode = "var";
    varCtx = {
      parentStep,
      baseStep,
      baseBoard: basePos.board,
      baseTurn: basePos.turn,
      varGame,
      varStep: 0,
      varTitle: entry?.name || "變化",
      returnStep: step
    };

    clearError();
    renderAll();
  }

  function exitVariation(){
    if (varCtx && Number.isInteger(varCtx.returnStep)) step = varCtx.returnStep;
    mode = "main";
    varCtx = null;
    renderAll();
  }

  // ===== Loaders for two indexes =====
  async function loadIndexGames(){
    const idx = await fetchJson("./data/games/index.json?v=" + Date.now());
    if (!Array.isArray(idx)) throw new Error("data/games/index.json 格式錯誤：必須是 JSON 陣列");
    const normalized = idx.map(normalizeIndexEntry).filter(Boolean);
    if (!normalized.length) throw new Error("data/games/index.json 沒有任何有效項目（需要 id + file）");
    gameIndex = normalized;
  }

  async function loadIndexLearning(){
    const idx = await fetchJson("./data/learning/index.json?v=" + Date.now());
    if (!Array.isArray(idx)) throw new Error("data/learning/index.json 格式錯誤：必須是 JSON 陣列");
    const normalized = idx.map(normalizeIndexEntry).filter(Boolean);
    if (!normalized.length) throw new Error("data/learning/index.json 沒有任何有效項目（需要 id + file）");
    lessonIndex = normalized;
  }

  function populateSelectFromIndex(indexArr){
    gameSelect.innerHTML = "";
    indexArr.forEach((g, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = g.title || g.id;
      gameSelect.appendChild(opt);
    });
    gameSelect.value = "0";
  }

  async function loadGamesMode(first=true){
    clearError();
    step = 0;
    mode = "main";
    varCtx = null;
    currentGame = null;
    currentLesson = null;
    lessonPos = 0;

    await loadIndexGames();
    populateSelectFromIndex(gameIndex);

    gameSelect.onchange = async () => {
      currentIndex = Number(gameSelect.value);
      await loadGame(currentIndex);
      gameSelect.blur();
    };

    currentIndex = 0;
    if (first) await loadGame(0);
  }

  async function loadLearningMode(first=true){
    clearError();
    step = 0;
    mode = "main";
    varCtx = null;
    currentGame = null;
    currentLesson = null;
    lessonPos = 0;

    await loadIndexLearning();
    populateSelectFromIndex(lessonIndex);

    gameSelect.onchange = async () => {
      const idx = Number(gameSelect.value);
      await loadLesson(idx);
      gameSelect.blur();
    };

    if (first) await loadLesson(0);
  }

  async function loadGame(i){
    clearError();
    step = 0;
    mode = "main";
    varCtx = null;
    currentGame = null;
    renderAll();

    const entry = gameIndex[i];
    if (!entry) throw new Error("找不到對局索引項目（games）");

    const raw = await fetchJson("./data/games/" + entry.file + "?v=" + Date.now());
    const game = normalizeGame(raw);

    if (!game.title) game.title = entry.title;
    if (!game.id) game.id = entry.id;

    currentGame = game;
    renderAll();
  }

  async function loadLesson(i){
    clearError();
    step = 0;
    mode = "main";
    varCtx = null;
    currentLesson = null;
    lessonPos = 0;
    renderAll();

    const entry = lessonIndex[i];
    if (!entry) throw new Error("找不到教學索引項目（learning）");

    const raw = await fetchJson("./data/learning/" + entry.file + "?v=" + Date.now());
    const lesson = normalizeLesson(raw);

    if (!lesson.title) lesson.title = entry.title;
    if (!lesson.id) lesson.id = entry.id;

    currentLesson = lesson;
    lessonPos = 0;
    renderAll();
  }

  // ===== Controls wiring =====
  function gotoPrevQuestion(){
    if (!currentLesson) return;
    if (lessonPos > 0){
      lessonPos--;
      step = 0;
      renderAll();
    }
  }
  function gotoNextQuestion(){
    if (!currentLesson) return;
    if (lessonPos < currentLesson.positions.length - 1){
      lessonPos++;
      step = 0;
      renderAll();
    }
  }

  function wireControls(){
    backBtn.addEventListener("click", exitVariation);

    firstBtn.addEventListener("click", () => {
      if (appMode === "learning") { gotoPrevQuestion(); return; }

      if (mode === "var" && varCtx){ varCtx.varStep = 0; renderAll(); return; }
      step = 0; renderAll();
    });

    prevBtn.addEventListener("click", () => {
      if (appMode === "learning"){
        step = Math.max(0, step-1);
        renderAll();
        return;
      }

      if (mode === "var" && varCtx){
        if (varCtx.varStep > 0){ varCtx.varStep--; renderAll(); }
        else exitVariation();
        return;
      }
      step = Math.max(0, step-1);
      renderAll();
    });

    nextBtn.addEventListener("click", () => {
      if (appMode === "learning"){
        const g = currentLesson?.positions?.[lessonPos]?.playable;
        const L = g ? g.moves.length : 0;
        step = Math.min(L, step+1);
        renderAll();
        return;
      }

      if (mode === "var" && varCtx){
        const L = varCtx.varGame.moves.length;
        varCtx.varStep = Math.min(L, varCtx.varStep+1);
        renderAll();
        return;
      }
      const L = currentGame ? currentGame.moves.length : 0;
      step = Math.min(L, step+1);
      renderAll();
    });

    lastBtn.addEventListener("click", () => {
      if (appMode === "learning") { gotoNextQuestion(); return; }

      if (mode === "var" && varCtx){
        varCtx.varStep = varCtx.varGame.moves.length;
        renderAll();
        return;
      }
      const L = currentGame ? currentGame.moves.length : 0;
      step = L;
      renderAll();
    });

    window.addEventListener("keydown", (e) => {
      const ae = document.activeElement;
      if (ae && ae.tagName === "SELECT") {
        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End"].includes(e.key)) e.preventDefault();
        return;
      }

      if (appMode === "learning"){
        const g = currentLesson?.positions?.[lessonPos]?.playable;
        if (!g) return;

        const L = g.moves.length;
        if (e.key === "ArrowLeft") { if (step>0) { step--; renderAll(); } }
        if (e.key === "ArrowRight") { if (step<L) { step++; renderAll(); } }
        if (e.key === "Home") { step = 0; renderAll(); }
        if (e.key === "End") { step = L; renderAll(); }
        return;
      }

      if (!currentGame) return;

      if (mode === "var" && varCtx){
        const L = varCtx.varGame.moves.length;
        if (e.key === "ArrowLeft") {
          if (varCtx.varStep > 0) { varCtx.varStep--; renderAll(); }
          else { exitVariation(); }
        }
        if (e.key === "ArrowRight") { if (varCtx.varStep < L) { varCtx.varStep++; renderAll(); } }
        if (e.key === "Home") { varCtx.varStep = 0; renderAll(); }
        if (e.key === "End") { varCtx.varStep = L; renderAll(); }
        return;
      }

      const L = currentGame.moves.length;
      if (e.key === "ArrowLeft") { if (step>0) { step--; renderAll(); } }
      if (e.key === "ArrowRight") { if (step<L) { step++; renderAll(); } }
      if (e.key === "Home") { step = 0; renderAll(); }
      if (e.key === "End") { step = L; renderAll(); }
    });

    modeSelect.addEventListener("change", async () => {
      try{
        clearError();
        const v = String(modeSelect.value);
        appMode = (v === "learning") ? "learning" : "games";
        function applyAppModeClass(){
          document.body.classList.remove("learningMode", "gamesMode");
          if (appMode === "learning") {
            document.body.classList.add("learningMode");
          } else {
            document.body.classList.add("gamesMode");
          }
        }
        applyAppModeClass();
        // reset view
        step = 0;
        mode = "main";
        varCtx = null;
        currentGame = null;
        currentLesson = null;
        lessonPos = 0;

        if (appMode === "learning") await loadLearningMode(true);
        else await loadGamesMode(true);
        renderAll();
      } catch (err){
        showError(String(err?.message ?? err));
      }
    });
  }

  async function init(){
    try{
      wireControls();
      renderCoords();
      appMode = "learning"; // initial mode
      document.body.classList.add("learningMode");
      modeSelect.value = "learning";
      await loadLearningMode(true);
    } catch (err){
      showError(String(err?.message ?? err));
    }
  }

  init();
})();
</script>
</body>
</html>



































