<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>黑白棋解說譜瀏覽器</title>
  <style>
    :root { --cell: 54px; --gap: 14px; --boardPad: 10px; --boardGap: 2px; --boardBd: 1px; --coord: 26px; }
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 0; padding: 18px; background:#0f172a; color:#e2e8f0; }
    .app { max-width: 1200px; margin: 0 auto; display: grid; grid-template-columns: 1.05fr 0.95fr; gap: var(--gap); }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr; } :root{ --cell: 46px; } }

    .panel { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 14px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .rowLeft { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    select, button {
      border-radius: 12px;
      padding: 9px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#e2e8f0;
    }
    select option { background-color: #0f172a; color: #e2e8f0; }
    select option:hover, select option:checked { background-color: #1c4e80; color: #ffffff; }

    button { cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.12); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor:not-allowed; }
    .pill { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); font-size: 14px; }
    .muted { opacity: 0.85; font-size: 13px; line-height:1.45; }

    .boardFrame{
      position: relative;
      padding-left: var(--coord);
      padding-top:  var(--coord);
      display: inline-block;
    }
    .coordTop{
      position: absolute;
      left: calc(var(--coord) + var(--boardPad) + var(--boardBd));
      top: 0;
      display: grid;
      grid-template-columns: repeat(8, var(--cell));
      gap: var(--boardGap);
      height: var(--coord);
      width: calc(8 * var(--cell) + 7 * var(--boardGap));
      align-items: center;
      justify-items: center;
      font-size: 18px;
      opacity: 0.9;
    }
    .coordLeft{
      position: absolute;
      left: 0;
      top: calc(var(--coord) + var(--boardPad) + var(--boardBd));
      display: grid;
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--boardGap);
      width: var(--coord);
      height: calc(8 * var(--cell) + 7 * var(--boardGap));
      align-items: center;
      justify-items: center;
      font-size: 18px;
      opacity: 0.9;
    }

    .boardWrap { display:flex; justify-content:center; }
    .board{
      display:grid;
      grid-template-columns: repeat(8, var(--cell));
      grid-template-rows: repeat(8, var(--cell));
      gap: var(--boardGap);
      background: rgba(255,255,255,0.08);
      padding: var(--boardPad);
      border-radius: 16px;
      border: var(--boardBd) solid rgba(255,255,255,0.12);
      user-select:none;
      touch-action: manipulation;
    }
    .cell {
      width: var(--cell); height: var(--cell);
      background: #166534;
      border-radius: 10px;
      position: relative;
      outline: 1px solid rgba(0,0,0,0.15);
      display:flex; align-items:center; justify-content:center;
    }
    .boardControls{
      margin-top: 12px;
      display:flex;
      justify-content:center;
    }
    .boardControls .rowLeft{
      justify-content:center;
    }
    body.varMode .cell { background:#1c4e80; }
    body.varMode .board { border-color: rgba(147,197,253,0.35); }
    body.varMode .item.active { background: rgba(147,197,253,0.14); outline-color: rgba(147,197,253,0.25); }

    #variationBox { display:flex; flex-direction:column; gap:8px; }
    .varBtn {
      display:flex; justify-content:space-between; align-items:center;
      border-radius: 12px; padding: 9px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#e2e8f0;
      cursor:pointer;
    }
    .varBtn:hover { background: rgba(255,255,255,0.12); }
    .varBtn small { opacity: .85; }

    .disc {
      width: calc(var(--cell) * 0.68);
      height: calc(var(--cell) * 0.68);
      border-radius: 50%;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.12), 0 10px 18px rgba(0,0,0,0.35);
    }
    .black { background: radial-gradient(circle at 35% 30%, #64748b 0%, #111827 60%, #0b1220 100%); }
    .white { background: radial-gradient(circle at 35% 30%, #ffffff 0%, #e2e8f0 55%, #cbd5e1 100%); }

    .lastMove::after{
      content:"";
      position:absolute;
      width: calc(var(--cell) * 0.28);
      height: calc(var(--cell) * 0.28);
      border-radius: 8px;
      border: 2px solid rgba(250,204,21,0.95);
      box-shadow: 0 0 0 3px rgba(250,204,21,0.18);
    }

    .right {
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height: 0;
    }
    .moves {
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 0;
    }

    .moveSection { order: 1; }
    .detailWrap  { order: 2; }

    .list {
      overflow:auto;
      max-height: 240px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.12);
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }
    .item {
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      cursor:pointer;
      display:flex;
      gap: 10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .item:last-child { border-bottom: 0; }
    .item:hover { background: rgba(255,255,255,0.06); }
    .item.active { background: rgba(250,204,21,0.10); outline: 1px solid rgba(250,204,21,0.20); }
    .tag { font-size: 14px; opacity: 0.85; white-space:nowrap; }
    .tag.moveNo { min-width: 90px; text-align: right; }
    .tag.moveNo::before { content: "★ "; visibility: hidden; }
    .item.hasVar .tag.moveNo::before { visibility: visible; }
    .mainText { font-size: 15px; line-height: 1.4; }

    .detailBox {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.12);
      padding: 12px;
      min-height: 120px;
      white-space: pre-wrap;
      line-height: 1.5;
      font-size: 18px;
    }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); }

    .error {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(248,113,113,0.35);
      background: rgba(248,113,113,0.10);
      color: #fecaca;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }

    @media (max-width: 980px){
      .detailWrap  { order: 1; }
      .moveSection { order: 2; }
      .list { max-height: 200px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="panel">
      <h1>黑白棋解說譜瀏覽器v1.16</h1>

      <div class="row">
        <div class="rowLeft">
          <span class="pill">解說</span>
          <select id="gameSelect" aria-label="Select game"></select>
          <span class="pill">黑：<b id="bCount">2</b>　白：<b id="wCount">2</b></span>
        </div>
      </div>

      <div id="errorBox" class="error" style="display:none;"></div>

      <div style="height:12px;"></div>
      <div class="boardWrap">
        <div class="boardFrame">
          <div class="coordTop" aria-hidden="true"></div>
          <div class="coordLeft" aria-hidden="true"></div>
          <div class="board" id="board" aria-label="Othello board"></div>
        </div>
      </div>
      <div class="boardControls">
        <div class="rowLeft">
          <button id="firstBtn">⏮ 第一手</button>
          <button id="backBtn" style="display:none;">↩ 回原對局</button>
          <button id="prevBtn">◀ 上一手</button>
          <button id="nextBtn">下一手 ▶</button>
          <button id="lastBtn">最後一手 ⏭</button>
        </div>
      </div>
    </div>

    <div class="right">
      <div class="panel moves">

        <div class="detailWrap">
          <div class="detailBox" id="detailBox">（尚未載入對局）</div>
          <div id="variationBox" style="margin-top:10px;"></div>
        </div>

        <div class="moveSection">
          <div class="row">
            <div class="rowLeft">
              <span class="pill">步驟清單（點選可跳轉）</span>
            </div>
            <div class="hotkeys muted">
              快捷鍵：<span class="kbd">←</span>/<span class="kbd">→</span> 前後手、<span class="kbd">Home</span>/<span class="kbd">End</span> 首尾。
            </div>
          </div>

          <div class="list" id="moveList" aria-label="Move list"></div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  const N = 8;
  const EMPTY = 0, BLACK = 1, WHITE = 2;
  const dirs = [
    [-1,-1],[-1,0],[-1,1],
    [0,-1],        [0,1],
    [1,-1],[1,0],[1,1]
  ];
  function other(p){ return p===BLACK ? WHITE : BLACK; }
  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function initBoard(){
    const b = Array.from({length:N}, () => Array(N).fill(EMPTY));
    b[3][3] = WHITE; b[3][4] = BLACK;
    b[4][3] = BLACK; b[4][4] = WHITE;
    return b;
  }

  function parseMove(s){
    if (!s) return null;
    const t = String(s).trim().toLowerCase();
    if (t === "pass") return { pass:true };
    const file = t.charCodeAt(0) - "a".charCodeAt(0);
    const rank = parseInt(t.slice(1), 10) - 1;
    if (Number.isNaN(rank) || file < 0 || file >= 8 || rank < 0 || rank >= 8) return null;
    return { r: rank, c: file, pass:false };
  }

  function getFlips(board, r, c, p){
    if (board[r][c] !== EMPTY) return [];
    const opp = other(p);
    const flips = [];
    for (const [dr,dc] of dirs){
      let rr = r + dr, cc = c + dc;
      const line = [];
      while (inBounds(rr,cc) && board[rr][cc] === opp){
        line.push([rr,cc]);
        rr += dr; cc += dc;
      }
      if (line.length && inBounds(rr,cc) && board[rr][cc] === p) flips.push(...line);
    }
    return flips;
  }
  function hasAnyLegalMove(board, p){
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== EMPTY) continue;
        if (getFlips(board, r, c, p).length) return true;
      }
    }
    return false;
  }
  function applyMove(board, moveObj, p){
    if (moveObj.pass) return { ok:true, last:null, board };
    const {r,c} = moveObj;
    const flips = getFlips(board, r, c, p);
    if (!flips.length) return { ok:false, last:null, board };
    board[r][c] = p;
    for (const [rr,cc] of flips) board[rr][cc] = p;
    return { ok:true, last:{r,c}, board };
  }

  function countDiscs(board){
    let b=0,w=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c]===BLACK) b++;
        else if (board[r][c]===WHITE) w++;
      }
    }
    return {b,w};
  }

  // ===== UI elements =====
  const boardEl = document.getElementById("board");
  const gameSelect = document.getElementById("gameSelect");
  const moveListEl = document.getElementById("moveList");
  const detailBox = document.getElementById("detailBox");
  const errorBox = document.getElementById("errorBox");

  const stepText = document.getElementById("stepText");
  const totalText = document.getElementById("totalText");
  const bCountEl = document.getElementById("bCount");
  const wCountEl = document.getElementById("wCount");

  const firstBtn = document.getElementById("firstBtn");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const lastBtn = document.getElementById("lastBtn");

  const backBtn = document.getElementById("backBtn");
  const variationBox = document.getElementById("variationBox");
  const coordTopEl  = document.querySelector(".coordTop");
  const coordLeftEl = document.querySelector(".coordLeft");

  function renderCoords(){
    if (coordTopEl){
      coordTopEl.innerHTML = "";
      "ABCDEFGH".split("").forEach(ch => {
        const d = document.createElement("div");
        d.textContent = ch;
        coordTopEl.appendChild(d);
      });
    }
    if (coordLeftEl){
      coordLeftEl.innerHTML = "";
      for (let i=1;i<=8;i++){
        const d = document.createElement("div");
        d.textContent = String(i);
        coordLeftEl.appendChild(d);
      }
    }
  }

  // ===== App state =====
  let gameIndex = [];
  let currentGame = null;
  let currentIndex = 0;
  let step = 0;
  let mode = "main";
  let varCtx = null;

  function showError(msg){
    errorBox.style.display = "block";
    errorBox.textContent = msg;
  }
  function clearError(){
    errorBox.style.display = "none";
    errorBox.textContent = "";
  }

  async function fetchJson(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`${url} 讀取失敗（HTTP ${res.status}）`);
    return await res.json();
  }

  function normalizeIndexEntry(e){
    const id = String(e?.id ?? "");
    const title = String(e?.title ?? id ?? "Untitled");
    const file = String(e?.file ?? "");
    if (!id || !file) return null;
    return { id, title, file };
  }

  function buildMovesFromRecord(record, comments){
    const rec = String(record ?? "").trim().toLowerCase();
    if (!rec) return [];
    if (rec.length % 2 !== 0) throw new Error("variation record 長度錯誤：必須是 2 的倍數");
    const c = (comments && typeof comments === "object") ? comments : {};
    const moves = [];
    for (let i=0;i<rec.length;i+=2){
      const s = (i/2)+1;
      const mv = rec.slice(i,i+2);
      moves.push({ move: mv, comment: String(c[String(s)] ?? c[s] ?? "") });
    }
    return moves;
  }

  function parseStartBoard(raw){
    // 目前先維持原本 json 格式；但保留未來從 json 讀 initBoard 的入口
    // 若未來 json 真的提供 startBoard，可在這裡接：raw.startBoard / raw.initBoard / raw.start 等
    const b = initBoard();
    return b;
  }
  function parseStartTurn(raw){
    // 未來可從 json 讀：raw.startTurn / raw.turn / raw.start.turn 等
    return BLACK;
  }

  function normalizeGame(g){
    const id = String(g?.id ?? "");
    const title = String(g?.title ?? id ?? "");
    const meta = String(g?.meta ?? "");
    const record = String(g?.record ?? "").trim().toLowerCase();
    if (!record) throw new Error("對局檔格式錯誤：缺少 record");

    const comments = (g?.comments && typeof g.comments === "object") ? g.comments : {};
    if (record.length % 2 !== 0) throw new Error("record 長度錯誤：必須是 2 的倍數（每手 2 字元）");

    const moves = [];
    for (let i = 0; i < record.length; i += 2) {
      const s = (i / 2) + 1;
      const move = record.slice(i, i + 2);
      moves.push({ move, comment: String(comments[String(s)] ?? comments[s] ?? "") });
    }

    const variations = (g?.variations && typeof g.variations === "object") ? g.variations : {};

    // 內部統一：起始盤面 + 起始輪到誰（未來 json 變更時只改這裡）
    const startBoard = parseStartBoard(g);
    const startTurn = parseStartTurn(g);

    return { id, title, meta, moves, variations, startBoard, startTurn };
  }

  // ===== Turn / PASS 相容的回放核心 =====
  function computePositionFrom(startBoard, startTurn, game, step){
    let board = startBoard.map(row => row.slice());
    let turn = startTurn;
    let last = null;

    for (let i=0;i<step;i++){
      const m = game.moves[i];
      const mo = parseMove(m.move);
      if (!mo) { 
        // 這裡你也可以選擇 throw；先維持相容
        continue;
      }
    
      // ✅ 隱性 PASS：如果目前這手沒有任何合法著手，就先把回合交給對方
      // 不消耗 record token，因為 record 裡下一個 token 就是對方的實際落子
      let guard = 0;
      while (!hasAnyLegalMove(board, turn)) {
        turn = other(turn);
        guard++;
        if (guard >= 2) break; // 兩邊都沒法下 => 對局實質結束
      }
    
      // 若兩邊都不能下，就不用再吃 token（避免亂套）
      if (guard >= 2 && !hasAnyLegalMove(board, turn)) {
        break;
      }
    
      // 套用這個 token（此時 turn 已經是「真正應該下的人」）
      const res = applyMove(board, mo, turn);
    
      // 若仍然非法：再做一次「嘗試視為對方下」（避免資料或規則外狀況）
      if (!res.ok) {
        const alt = other(turn);
        const res2 = applyMove(board, mo, alt);
        if (res2.ok) {
          last = res2.last;
          turn = other(alt);
          continue;
        }
        // 兩邊都不行：資料真的不一致，這裡建議直接 continue 或 throw
        continue;
      }
    
      last = res.last;
      turn = other(turn);
    }
    return { board, turn, last };
  }

  function computePosition(game, step){
    const startBoard = game?.startBoard ? game.startBoard : initBoard();
    const startTurn  = (game && (game.startTurn===BLACK || game.startTurn===WHITE)) ? game.startTurn : BLACK;
    return computePositionFrom(startBoard, startTurn, game, step);
  }

  function buildPlayersForMoves(startBoard, startTurn, game){
    const players = [];
    let board = startBoard.map(row => row.slice());
    let turn = startTurn;
  
    for (let i=0;i<game.moves.length;i++){
      const mo = parseMove(game.moves[i].move);
      if (!mo){
        // 維持相容：遇到怪 token 就先當作不處理，玩家標籤也給目前 turn
        players[i] = turn;
        continue;
      }
  
      // ✅ 隱性 PASS：若目前輪到的人沒合法手，就先把回合交出去（不消耗 token）
      let guard = 0;
      while (!hasAnyLegalMove(board, turn)) {
        turn = other(turn);
        guard++;
        if (guard >= 2) break; // 兩邊都沒法下
      }
  
      // 若兩邊都不能下：之後的 token 其實也不該再有意義
      if (guard >= 2 && !hasAnyLegalMove(board, turn)) {
        players[i] = turn; // 隨便標一下，後面也會一路維持
        continue;
      }
  
      // 此 token 的真正下棋方
      players[i] = turn;
  
      // 套用落子到 local board，讓下一步的 turn 推導與盤面一致
      if (mo.pass){
        // 明示 PASS：不落子，但依你的規則「不切手」
        continue;
      }
  
      const res = applyMove(board, mo, turn);
  
      // 若仍非法：嘗試當作對方落子（避免資料/規則外狀況）
      if (!res.ok) {
        const alt = other(turn);
        const res2 = applyMove(board, mo, alt);
        if (res2.ok) {
          turn = other(alt);
          continue;
        }
        // 兩邊都不行：就不更新 board、不切手（避免越走越歪）
        continue;
      }
  
      turn = other(turn);
    }
  
    return players;
  }
  function renderBoard(board, last){
    boardEl.innerHTML = "";
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const cell = document.createElement("div");
        cell.className = "cell";
        if (last && last.r===r && last.c===c) cell.classList.add("lastMove");

        const v = board[r][c];
        if (v !== EMPTY){
          const d = document.createElement("div");
          d.className = "disc " + (v===BLACK ? "black" : "white");
          cell.appendChild(d);
        }
        boardEl.appendChild(cell);
      }
    }
  }

  function scrollActiveInList(){
    if (!moveListEl) return;
    const active = moveListEl.querySelector(".item.active");
    if (!active) return;

    const top = active.offsetTop;
    const bottom = top + active.offsetHeight;

    const viewTop = moveListEl.scrollTop;
    const viewBottom = viewTop + moveListEl.clientHeight;

    if (top < viewTop) moveListEl.scrollTop = top - 8;
    else if (bottom > viewBottom) moveListEl.scrollTop = bottom - moveListEl.clientHeight + 8;
  }

  function renderMoveList(game, startBoardForThisGame, startTurnForThisGame){
    moveListEl.innerHTML = "";
    const activeStep = (mode === "var" && varCtx) ? varCtx.varStep : step;
    const players = buildPlayersForMoves(startBoardForThisGame, startTurnForThisGame, game);

    const initItem = document.createElement("div");
    initItem.className = "item" + (activeStep===0 ? " active":"");
    initItem.innerHTML = `
      <div>
        <div class="mainText"><b>初始局面</b></div>
        <div class="tag">Move 0</div>
      </div>
      <div class="tag">—</div>
    `;
    initItem.addEventListener("click", () => {
      if (mode === "var" && varCtx) varCtx.varStep = 0;
      else step = 0;
      renderAll();
    });
    moveListEl.appendChild(initItem);

    for (let i=0;i<game.moves.length;i++){
      const m = game.moves[i];
      const s = i+1;
      const key = String(s);
      const hasVar = Array.isArray(game.variations?.[key]?.entries) && game.variations[key].entries.length;
      const item = document.createElement("div");
      item.className = "item" + (activeStep===s ? " active":"") + (hasVar ? " hasVar" : "");

      const p = players[i];
      const playerLabel = (p === BLACK) ? "黑" : "白";

      const moveLower = String(m.move).toLowerCase();
      const moveText = (moveLower === "pass") ? "PASS" : String(m.move);

      const shortComment = (m.comment || "").trim().replace(/\s+/g," ");
      const preview = shortComment.length ? shortComment.slice(0, 24) + (shortComment.length>24 ? "…" : "") : "";

      item.innerHTML = `
        <div>
          <div class="mainText"><b>${playerLabel}</b>：${moveText}</div>
          <div class="tag">${preview}</div>
        </div>
        <div class="tag moveNo">Move ${s}</div>
      `;
      item.addEventListener("click", () => {
        if (mode === "var" && varCtx) varCtx.varStep = s;
        else step = s;
        renderAll();
      });
      moveListEl.appendChild(item);
    }

    scrollActiveInList();
  }

  function renderDetail(game, pos){
    if (variationBox) variationBox.innerHTML = "";

    if (mode === "var" && varCtx){
      if (varCtx.varStep === 0){
        detailBox.textContent = `【變化分支】${varCtx.varTitle}`;
      } else {
        const i = varCtx.varStep - 1;
        const m = varCtx.varGame.moves[i];
        detailBox.textContent = String((m.comment || "")).trim();
      }
      return;
    }

    if (step === 0){
      detailBox.textContent = game.meta ? `【對局資訊】\n${game.meta}` : "（初始局面）";
    } else {
      const i = step - 1;
      const m = game.moves[i];
      const comment = String((m.comment || "")).trim();
      const key = String(step);
      const vPack = game.variations?.[key];
      const entries = vPack?.entries;
      const hasVarHere = Array.isArray(entries) && entries.length;
      
      detailBox.textContent = hasVarHere ? `【變化圖】\n${comment}`: comment;
    }

    const key = String(step);
    const vPack = game.variations?.[key];
    const entries = vPack?.entries;
    if (variationBox && Array.isArray(entries) && entries.length){
      entries.forEach((entry) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "varBtn";
        const name = entry.name || "變化";
        const rec = String(entry.record || "");
        btn.innerHTML = `<span><b>${name}</b></span><small>${rec}</small>`;
        btn.addEventListener("click", () => enterVariation(step, entry, vPack));
        variationBox.appendChild(btn);
      });
    }
  }

  function renderHeader(game, pos){
    if (stepText) stepText.textContent = (mode === "var" && varCtx) ? varCtx.parentStep : step;
    if (totalText) totalText.textContent = game.moves.length;

    const {b,w} = countDiscs(pos.board);
    if (bCountEl) bCountEl.textContent = b;
    if (wCountEl) wCountEl.textContent = w;

    const atStart = (mode === "var" && varCtx) ? (varCtx.varStep === 0) : (step === 0);
    const atEnd = (mode === "var" && varCtx) ? (varCtx.varStep === varCtx.varGame.moves.length) : (step === game.moves.length);
    const inVar = (mode === "var" && varCtx);
    if (firstBtn) firstBtn.disabled = atStart;
    if (prevBtn)  prevBtn.disabled  = inVar ? false : atStart;
    if (nextBtn)  nextBtn.disabled  = atEnd;
    if (lastBtn)  lastBtn.disabled  = atEnd;
    if (mode === "var") {
      if (backBtn)  backBtn.style.display  = "";
      if (firstBtn) firstBtn.style.display = "none";
    } else {
      if (backBtn)  backBtn.style.display  = "none";
      if (firstBtn) firstBtn.style.display = "";
    }
  }

  function renderAll(){
    if (!currentGame){
      detailBox.textContent = "（尚未載入對局）";
      if (variationBox) variationBox.innerHTML = "";
      return;
    }

    if (mode === "var" && varCtx){
      const pos = computePositionFrom(varCtx.baseBoard, varCtx.baseTurn, varCtx.varGame, varCtx.varStep);
      renderBoard(pos.board, pos.last);
      renderMoveList(varCtx.varGame, varCtx.baseBoard, varCtx.baseTurn);
      renderDetail(varCtx.varGame, pos);
      renderHeader(varCtx.varGame, pos);
      return;
    }

    const pos = computePosition(currentGame, step);
    renderBoard(pos.board, pos.last);
    renderMoveList(currentGame, currentGame.startBoard ?? initBoard(), currentGame.startTurn ?? BLACK);
    renderDetail(currentGame, pos);
    renderHeader(currentGame, pos);
  }

  function enterVariation(parentStep, entry, vPack){
    if (!currentGame) throw new Error("currentGame 尚未載入");

    const baseStep = (vPack && Number.isInteger(vPack.baseStep))
      ? vPack.baseStep
      : parentStep;

    const basePos = computePosition(currentGame, baseStep);

    const varGame = {
      id: "var",
      title: entry?.name || "變化",
      meta: "",
      moves: buildMovesFromRecord(entry?.record, entry?.comments)
    };

    if (!varGame.moves.length) throw new Error("這個變化圖的 record 是空的，無法進入");

    mode = "var";
    varCtx = {
      parentStep,
      baseStep,
      baseBoard: basePos.board,
      baseTurn: basePos.turn,
      varGame,
      varStep: 0,
      varTitle: entry?.name || "變化",
      returnStep: step
    };

    document.body.classList.add("varMode");
    if (backBtn) backBtn.style.display = "";
    clearError();
    renderAll();
  }

  function exitVariation(){
    if (varCtx && Number.isInteger(varCtx.returnStep)) step = varCtx.returnStep;
    mode = "main";
    varCtx = null;
    document.body.classList.remove("varMode");
    if (backBtn) backBtn.style.display = "none";
    renderAll();
  }

  async function loadIndex(){
    clearError();
    const idx = await fetchJson("./data/index.json?v=" + Date.now());
    if (!Array.isArray(idx)) throw new Error("index.json 格式錯誤：必須是 JSON 陣列");

    const normalized = idx.map(normalizeIndexEntry).filter(Boolean);
    if (!normalized.length) throw new Error("index.json 沒有任何有效項目（需要 id + file）");

    gameIndex = normalized;

    gameSelect.innerHTML = "";
    gameIndex.forEach((g, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = g.title || g.id;
      gameSelect.appendChild(opt);
    });

    currentIndex = 0;
    gameSelect.value = "0";
    gameSelect.addEventListener("change", async () => {
      currentIndex = Number(gameSelect.value);
      await loadGame(currentIndex);
      gameSelect.blur();
    });
  }

  async function loadGame(i){
    clearError();
    step = 0;
    currentGame = null;
    renderAll();

    const entry = gameIndex[i];
    if (!entry) throw new Error("找不到對局索引項目");

    const game = normalizeGame(
      await fetchJson("./data/" + entry.file + "?v=" + Date.now())
    );

    if (!game.moves) throw new Error("對局檔格式錯誤：缺少 moves");
    if (!game.title) game.title = entry.title;
    if (!game.id) game.id = entry.id;

    currentGame = game;
    renderAll();
  }

  function wireControls(){
    if (backBtn) backBtn.addEventListener("click", exitVariation);

    firstBtn.addEventListener("click", () => {
      if (mode === "var" && varCtx){ varCtx.varStep = 0; renderAll(); return; }
      step = 0; renderAll();
    });

    prevBtn.addEventListener("click", () => {
      if (mode === "var" && varCtx){
        if (varCtx.varStep > 0){ varCtx.varStep--; renderAll(); }
        else exitVariation();
        return;
      }
      step = Math.max(0, step-1);
      renderAll();
    });

    nextBtn.addEventListener("click", () => {
      if (mode === "var" && varCtx){
        const L = varCtx.varGame.moves.length;
        varCtx.varStep = Math.min(L, varCtx.varStep+1);
        renderAll();
        return;
      }
      const L = currentGame ? currentGame.moves.length : 0;
      step = Math.min(L, step+1);
      renderAll();
    });

    lastBtn.addEventListener("click", () => {
      if (mode === "var" && varCtx){
        varCtx.varStep = varCtx.varGame.moves.length;
        renderAll();
        return;
      }
      const L = currentGame ? currentGame.moves.length : 0;
      step = L;
      renderAll();
    });

    window.addEventListener("keydown", (e) => {
      const ae = document.activeElement;
      if (ae && ae.tagName === "SELECT") {
        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End"].includes(e.key)) e.preventDefault();
        return;
      }
      if (!currentGame) return;

      if (mode === "var" && varCtx){
        const L = varCtx.varGame.moves.length;
        if (e.key === "ArrowLeft") {
          if (varCtx.varStep > 0) { varCtx.varStep--; renderAll(); }
          else { exitVariation(); }
        }
        if (e.key === "ArrowRight") { if (varCtx.varStep < L) { varCtx.varStep++; renderAll(); } }
        if (e.key === "Home") { varCtx.varStep = 0; renderAll(); }
        if (e.key === "End") { varCtx.varStep = L; renderAll(); }
        return;
      }

      const L = currentGame.moves.length;
      if (e.key === "ArrowLeft") { if (step>0) { step--; renderAll(); } }
      if (e.key === "ArrowRight") { if (step<L) { step++; renderAll(); } }
      if (e.key === "Home") { step = 0; renderAll(); }
      if (e.key === "End") { step = L; renderAll(); }
    });
  }

  async function init(){
    try{
      wireControls();
      renderCoords();
      await loadIndex();
      await loadGame(0);
    } catch (err){
      showError(String(err?.message ?? err));
    }
  }
  init();
})();
</script>
</body>
</html>















